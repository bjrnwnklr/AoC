# Day 18

## Challenge

### Part 1

A massive underground vault. You generate a map of the tunnels (your puzzle input). The tunnels are too narrow to move diagonally.

Only one entrance (marked @) is present among the open passages (marked .) and stone walls (#), but you also detect an assortment of keys (shown as lowercase letters) and doors (shown as uppercase letters). Keys of a given letter open the door of the same letter: a opens A, b opens B, and so on. You aren't sure which key you need to disable the tractor beam, so you'll need to collect all of them.

**How many steps is the shortest path that collects all of the keys?**

#### Ideas

Use BFS, but add a register of keys at a given step into the current position (bit coded). Valid neighbors unlock depending on the keys you hold.

-   To be efficient, create a graph that has keys and the starting point as nodes and the number of steps and doors between them as edges. This way, we can then traverse the maze jumping from key to key (and check if a key is reachable by using the bitmask of the current keys).
-   We can use BFS for this i think... Start from starting point, then repeat from each key.


**Correct answer for part 1 is 4544** (from [Jonathan Paulson's solution](https://www.reddit.com/r/adventofcode/comments/ec8090/2019_day_18_solutions/fb9wfnz/?utm_source=share&utm_medium=web2x))


Update 7 Jan 2020:
- My BFS seems to have been wrong!!! I have now managed to get the correct answer (4544) for the input using the changed BFS used in the initial mapping of keys and the Dijkstra for finding the shortest path. Correct file: aoc2019_18_dijkstra_2.py.

- Compare the key_graph distances between the two versions (aoc2019_18_dijkstra.py and aoc2019_18_dijkstra_2.py)
- Understand what i have done wrong on the BFS
- Change the initial BFS version to use the correct BFS

### Part 2

## Learnings
