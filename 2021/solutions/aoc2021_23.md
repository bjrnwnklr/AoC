# Advent of Code 2021, day 23

Current Dijkstra implementation is very slow. Possible reason is the implementation of the `Burrow` class with multiple dictionaries and the `move_copy` method, which copies the dictionaries one by one.

Ideas to improve:

-   01: Use `deepcopy` of the `Burrow` class instead of manually copying.
-   02: Simplify the `Burrow` data structure:
    -   DONE 01 Use a `Pod` dataclass to store
        -   Type (A, B, C, D)
        -   Location (r, c)
        -   Locked status (True / False)
    -   02 DONE A single `self.pods` dictionary with `id: Pod` key / value pairs
        -   DONE This will elminate the need to have the following attributes in `Burrow`:
            -   `grid`
            -   `types`
            -   `locked`
        -   DONE Adjust the `possible_moves` method accordingly
            -   check if path from one to another slot is clear (currently checking if hallway is all '...')
            -   locked / type lookups
        -   DONE Adjust the `move_copy` method accordingly
            -   Only change the pod's location and locked status
        -   DONE Adjust the `state` method accordingly
            -   Assemble the string representation as 11 + 4 + 4 dots and replace the respective slots with the pod type letters based on each pod's location
        -   DONE Adjust the `lock` method in `Burrow` class to use the `locked` attribute of the `Pod` class.
-   03: Implement `Burrow` hallway and rooms as a graph and calculate distances using a BFS (or DFS?)
-   04: Pre-calculate distances between positions (or cache them using `functools.cache`) - only do this if not implementing 03 graph.

## Initial time for part 1 puzzle:

```python
INFO:root:Target reached: ...........ABCDABCD, cost 15516.
Elapsed time to run part1: 1.90191 seconds.
Part 1: 15516
Part 2: 1
```

## Error with example:

```

E                       AssertionError: Pod Pod(pid=0, type='B', pos=(1, 4), locked=False) not expected in location (1, 4).
E                       self.pods={0: Pod(pid=0, type='B', pos=(1, 4), locked=False), 1: Pod(pid=1, type='C', pos=(0, 3), locked=False), 2: Pod(pid=2, type='B', pos=(2, 4), locked=False), 3: Pod(pid=3, type='D', pos=(1, 8), locked=False), 4: Pod(pid=4, type='A', pos=(2, 2), locked=True), 5: Pod(pid=5, type='D', pos=(0, 0), locked=False), 6: Pod(pid=6, type='C', pos=(2, 6), locked=True), 7: Pod(pid=7, type='A', pos=(2, 8), locked=False)}
E                       self.state()='D..C........B.DABCA'
E                       p=Pod(pid=2, type='B', pos=(2, 4), locked=False)
```

Somehow, pod 2 in pos (2, 4) should be locked, but is not locked so we are trying to move it!
