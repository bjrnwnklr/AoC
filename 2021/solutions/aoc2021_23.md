# Advent of Code 2021, day 23

Current Dijkstra implementation is very slow. Possible reason is the implementation of the `Burrow` class with multiple dictionaries and the `move_copy` method, which copies the dictionaries one by one.

Ideas to improve:

-   01: Use `deepcopy` of the `Burrow` class instead of manually copying.
    -   NEW Manually implement `__deepcopy__` method as described [here](https://stackoverflow.com/questions/24756712/deepcopy-is-extremely-slow). This basically reverts back to the behaviour in the original solution where i "deepcopied" the class instance.
-   02: Simplify the `Burrow` data structure:
    -   DONE 01 Use a `Pod` dataclass to store
        -   Type (A, B, C, D)
        -   Location (r, c)
        -   Locked status (True / False)
    -   02 DONE A single `self.pods` dictionary with `id: Pod` key / value pairs
        -   DONE This will elminate the need to have the following attributes in `Burrow`:
            -   `grid`
            -   `types`
            -   `locked`
        -   DONE Adjust the `possible_moves` method accordingly
            -   check if path from one to another slot is clear (currently checking if hallway is all '...')
            -   locked / type lookups
        -   DONE Adjust the `move_copy` method accordingly
            -   Only change the pod's location and locked status
        -   DONE Adjust the `state` method accordingly
            -   Assemble the string representation as 11 + 4 + 4 dots and replace the respective slots with the pod type letters based on each pod's location
        -   DONE Adjust the `lock` method in `Burrow` class to use the `locked` attribute of the `Pod` class.
-   03: Implement `Burrow` hallway and rooms as a graph and calculate distances using a BFS (or DFS?)
-   04: Pre-calculate distances between positions (or cache them using `functools.cache`) - only do this if not implementing 03 graph.

## Initial time for part 1 puzzle:

```python
INFO:root:Target reached: ...........ABCDABCD, cost 15516.
Elapsed time to run part1: 1.90191 seconds.
Part 1: 15516
Part 2: 1
```

## After moving to PODS

It is very slow now!

```python
INFO:root:Target reached: ...........ABCDABCD, cost 15516.
INFO:root:Target path: ['A..........D.BCBADC', 'AA.........D.BCB.DC', 'AA.........D..CBBDC', 'AA...C.....D...BBDC', 'AA...C.D...D...BB.C', 'AA.....D...D...BBCC', 'AA...D.D.......BBCC', 'AA.B.D.D........BCC', 'A..B.D.D.......ABCC', '...B.D.D...A...ABCC', '.....D.D...AB..ABCC', '.....D.D.C.AB..ABC.', '.....D...C.AB..ABCD', '.....D.....ABC.ABCD', '...........ABCDABCD']
Elapsed time to run part1: 29.85269 seconds.
Part 1: 15516
Part 2: 1
```

### Profiling using `scalene` profiler

Profiling shows that 58% time is spent with the `move_copy` function, specifically the `deepcopy` taking a long time:

```
function summary for solutions/aoc2021_â€¦
40                  Burrow.__init__
68                  Burrow.lock
91      9%  1       Burrow.state
115     22% 4       Burrow.moving_cost
156     4%          Burrow.possible_moves
306     58% 1% 15   Burrow.move_copy
334     2%          Burrow.__lt__
355     2%  7%      dijkstra


317     57% 1% 15   b_copy = copy.deepcopy(self)
```

After changing from `deepcopy` to manually copying and implementing a simple `copy` method for the `Pod` class, the time dropped by more than half:

```python
INFO:root:Target reached: ...........ABCDABCD, cost 15516.
INFO:root:Target path: ['A..........D.BCBADC', 'AA.........D.BCB.DC', 'AA.........D..CBBDC', 'AA...C.....D...BBDC', 'AA...C.D...D...BB.C', 'AA.....D...D...BBCC', 'AA...D.D.......BBCC', 'AA.B.D.D........BCC', 'A..B.D.D.......ABCC', '...B.D.D...A...ABCC', '.....D.D...AB..ABCC', '.....D.D.C.AB..ABC.', '.....D...C.AB..ABCD', '.....D.....ABC.ABCD', '...........ABCDABCD']
INFO:root:Number of states processed: steps=90270
Elapsed time to run part1: 14.72358 seconds.
Part 1: 15516
Part 2: 1
```

It is still using too many steps (90270 vs the 24549 the original solution requires).

This solution needs a complete rewrite without classes / objects.
